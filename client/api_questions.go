/*
 * Stack Exchange API
 *
 * Stack Exchange API
 *
 * API version: 2.2
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package stackexchange

import (
	"context"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type QuestionsApiService service

/*
QuestionsApiService
Gets all the questions on the site. This method allows you make fairly flexible queries across the entire corpus of questions on a site.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param site
 * @param optional nil or *GetFeaturedQuestionsOpts - Optional Parameters:
 * @param "Fromdate" (optional.Int32) -
 * @param "Todate" (optional.Int32) -
 * @param "Min" (optional.Int32) -
 * @param "Max" (optional.Int32) -
 * @param "Tagged" (optional.String) -
 * @param "Order" (optional.String) -
 * @param "Sort" (optional.String) -
 * @param "Page" (optional.Int32) -
 * @param "Pagesize" (optional.Int32) -
@return QuestionsResponse
*/

type GetFeaturedQuestionsOpts struct {
	Fromdate optional.Int32
	Todate   optional.Int32
	Min      optional.Int32
	Max      optional.Int32
	Tagged   optional.String
	Order    optional.String
	Sort     optional.String
	Page     optional.Int32
	Pagesize optional.Int32
}

func (a *QuestionsApiService) GetFeaturedQuestions(ctx context.Context, site string, localVarOptionals *GetFeaturedQuestionsOpts) (QuestionsResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue QuestionsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/questions/featured"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fromdate.IsSet() {
		localVarQueryParams.Add("fromdate", parameterToString(localVarOptionals.Fromdate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Todate.IsSet() {
		localVarQueryParams.Add("todate", parameterToString(localVarOptionals.Todate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Min.IsSet() {
		localVarQueryParams.Add("min", parameterToString(localVarOptionals.Min.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Max.IsSet() {
		localVarQueryParams.Add("max", parameterToString(localVarOptionals.Max.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tagged.IsSet() {
		localVarQueryParams.Add("tagged", parameterToString(localVarOptionals.Tagged.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Order.IsSet() {
		localVarQueryParams.Add("order", parameterToString(localVarOptionals.Order.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Pagesize.IsSet() {
		localVarQueryParams.Add("pagesize", parameterToString(localVarOptionals.Pagesize.Value(), ""))
	}
	localVarQueryParams.Add("site", parameterToString(site, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v QuestionsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
QuestionsApiService
Gets all the questions on the site. This method allows you make fairly flexible queries across the entire corpus of questions on a site.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param site
 * @param optional nil or *GetQuestionsOpts - Optional Parameters:
 * @param "Fromdate" (optional.Int32) -
 * @param "Todate" (optional.Int32) -
 * @param "Min" (optional.Int32) -
 * @param "Max" (optional.Int32) -
 * @param "Tagged" (optional.String) -
 * @param "Order" (optional.String) -
 * @param "Sort" (optional.String) -
 * @param "Page" (optional.Int32) -
 * @param "Pagesize" (optional.Int32) -
@return QuestionsResponse
*/

type GetQuestionsOpts struct {
	Fromdate optional.Int32
	Todate   optional.Int32
	Min      optional.Int32
	Max      optional.Int32
	Tagged   optional.String
	Order    optional.String
	Sort     optional.String
	Page     optional.Int32
	Pagesize optional.Int32
}

func (a *QuestionsApiService) GetQuestions(ctx context.Context, site string, localVarOptionals *GetQuestionsOpts) (QuestionsResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue QuestionsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/questions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fromdate.IsSet() {
		localVarQueryParams.Add("fromdate", parameterToString(localVarOptionals.Fromdate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Todate.IsSet() {
		localVarQueryParams.Add("todate", parameterToString(localVarOptionals.Todate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Min.IsSet() {
		localVarQueryParams.Add("min", parameterToString(localVarOptionals.Min.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Max.IsSet() {
		localVarQueryParams.Add("max", parameterToString(localVarOptionals.Max.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tagged.IsSet() {
		localVarQueryParams.Add("tagged", parameterToString(localVarOptionals.Tagged.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Order.IsSet() {
		localVarQueryParams.Add("order", parameterToString(localVarOptionals.Order.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Pagesize.IsSet() {
		localVarQueryParams.Add("pagesize", parameterToString(localVarOptionals.Pagesize.Value(), ""))
	}
	localVarQueryParams.Add("site", parameterToString(site, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v QuestionsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
QuestionsApiService
Returns questions which have received no answers. Compare with /questions/unanswered which merely returns questions that the sites consider insufficiently well answered.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param site
 * @param optional nil or *GetQuestionsWithoutAnswersOpts - Optional Parameters:
 * @param "Fromdate" (optional.Int32) -
 * @param "Todate" (optional.Int32) -
 * @param "Min" (optional.Int32) -
 * @param "Max" (optional.Int32) -
 * @param "Tagged" (optional.String) -
 * @param "Order" (optional.String) -
 * @param "Sort" (optional.String) -
 * @param "Page" (optional.Int32) -
 * @param "Pagesize" (optional.Int32) -
@return QuestionsResponse
*/

type GetQuestionsWithoutAnswersOpts struct {
	Fromdate optional.Int32
	Todate   optional.Int32
	Min      optional.Int32
	Max      optional.Int32
	Tagged   optional.String
	Order    optional.String
	Sort     optional.String
	Page     optional.Int32
	Pagesize optional.Int32
}

func (a *QuestionsApiService) GetQuestionsWithoutAnswers(ctx context.Context, site string, localVarOptionals *GetQuestionsWithoutAnswersOpts) (QuestionsResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue QuestionsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/questions/no-answers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fromdate.IsSet() {
		localVarQueryParams.Add("fromdate", parameterToString(localVarOptionals.Fromdate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Todate.IsSet() {
		localVarQueryParams.Add("todate", parameterToString(localVarOptionals.Todate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Min.IsSet() {
		localVarQueryParams.Add("min", parameterToString(localVarOptionals.Min.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Max.IsSet() {
		localVarQueryParams.Add("max", parameterToString(localVarOptionals.Max.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tagged.IsSet() {
		localVarQueryParams.Add("tagged", parameterToString(localVarOptionals.Tagged.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Order.IsSet() {
		localVarQueryParams.Add("order", parameterToString(localVarOptionals.Order.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Pagesize.IsSet() {
		localVarQueryParams.Add("pagesize", parameterToString(localVarOptionals.Pagesize.Value(), ""))
	}
	localVarQueryParams.Add("site", parameterToString(site, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v QuestionsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
QuestionsApiService
Gets all the questions on the site. This method allows you make fairly flexible queries across the entire corpus of questions on a site.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param site
 * @param optional nil or *GetUnansweredQuestionsOpts - Optional Parameters:
 * @param "Fromdate" (optional.Int32) -
 * @param "Todate" (optional.Int32) -
 * @param "Min" (optional.Int32) -
 * @param "Max" (optional.Int32) -
 * @param "Tagged" (optional.String) -
 * @param "Order" (optional.String) -
 * @param "Sort" (optional.String) -
 * @param "Page" (optional.Int32) -
 * @param "Pagesize" (optional.Int32) -
@return QuestionsResponse
*/

type GetUnansweredQuestionsOpts struct {
	Fromdate optional.Int32
	Todate   optional.Int32
	Min      optional.Int32
	Max      optional.Int32
	Tagged   optional.String
	Order    optional.String
	Sort     optional.String
	Page     optional.Int32
	Pagesize optional.Int32
}

func (a *QuestionsApiService) GetUnansweredQuestions(ctx context.Context, site string, localVarOptionals *GetUnansweredQuestionsOpts) (QuestionsResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue QuestionsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/questions/unanswered"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fromdate.IsSet() {
		localVarQueryParams.Add("fromdate", parameterToString(localVarOptionals.Fromdate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Todate.IsSet() {
		localVarQueryParams.Add("todate", parameterToString(localVarOptionals.Todate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Min.IsSet() {
		localVarQueryParams.Add("min", parameterToString(localVarOptionals.Min.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Max.IsSet() {
		localVarQueryParams.Add("max", parameterToString(localVarOptionals.Max.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tagged.IsSet() {
		localVarQueryParams.Add("tagged", parameterToString(localVarOptionals.Tagged.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Order.IsSet() {
		localVarQueryParams.Add("order", parameterToString(localVarOptionals.Order.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Pagesize.IsSet() {
		localVarQueryParams.Add("pagesize", parameterToString(localVarOptionals.Pagesize.Value(), ""))
	}
	localVarQueryParams.Add("site", parameterToString(site, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v QuestionsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
